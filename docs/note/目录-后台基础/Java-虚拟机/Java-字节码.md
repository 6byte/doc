# Java-字节码

## 概览

```
1. .class文件只要符合JVM规范,生成方式不限任何语言
2.	.class实质：是严格按照JVM的规范,编译产生的二进制文件
	以表的形式组织代码中的各个部分,
	一个.class文件等于一张表
3.  .class表重要组成部分:
		常量池，访问标记，当前类，类的属性，类的方法，类的字段，类的接口，父类，magic!
		magic：识别文件类型是否是class文件
		访问标志:public ,private,protected
4. .class是反射的基础
```

jvm基础

```
1.每个java程序至少有一个线程
2.一个线程会分配一个java栈
3.栈可以有多个栈帧
4.一个方法=一个栈帧=局部变量表+操作栈+动态链接+其他信息

加载：
本地变量表 和 栈帧局部变量表 进行数据交互
```

### Java栈

```
1.与java运行相关，随线程一齐创建消亡，并不存在垃圾回收问题
2.存放
	1.变量，和八种基本数据类型，
	2.存放对象引用
```

### 方法区

>存放类的基本信息

### 本地方法栈

>运行c语言或其他语言

### 内存屏障

```
1.CPU分多级缓存:L1,L2,L3
    优点:提高了数据访问性能
    缺点:
        1.不能实时的和内存发生信息交换
        2.不同线程对同一个变量的缓存值不同

硬件层的内存屏障分为两种：读屏障,写屏障。【内存屏障是硬件层的】

2.JAVA 通过volatile解决缓存读写不一致问题<内存屏障>
    1.可见性，对于一个该变量的读，一定能看到读之前最后的写入。
    2.原子性，对volatile变量的读写具有原子性，即单纯读和写的操作，都不会受到干扰。
```

### 变量存储位置

```
一.方法区
    1.static final修饰的成员变量，成员方法
    2.静态变量
    3.字节码文件，静态方法，

二.栈<虚拟机栈>
    1.八种基本数据类型
    2.局部变量
    3.局部的对象的引用

三.堆
    1.由new产生的所有对象
    2.java数组也在堆中开辟内存空间
    3.全局变量

```

### 堆结构

```
新生代，养老区<重GC>，元空间
元空间:	物理内存
新生代分:
		1.伊甸区		
		2.幸存0区
		3.幸存1区
新生代调优
        xms:	初始化大小
        xmx:	最大化大小
```



### 加载机制

```
为什么需要这样的机制
	1.JVM根据classpath查找类，路径靠前优先级越高
	2.如何控制加载顺序，如子类和父类
	3.如何避免加载恶意的类，如，重新定义一个Object类
类加载器完美解决了上面的问题
Bootstrap	:	系统类rt.jar
扩展类加载器	:	jre/lib.ext
应用类加载器  :	classpath
用户自定义加载器	:	App


```



#### 类加载器

```
BootstrapClassloader:		基本启动类加载器，保证Java能够正常执行
ExtensionClassloader:			java更新类的加载器,如javax
ApplicationClassloader:		应用加载器
双亲委派机制
沙箱安全机制

```

### 字节码加密

```
字节码混淆：ProGuard
```

